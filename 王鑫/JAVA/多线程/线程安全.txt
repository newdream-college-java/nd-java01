一、线程的6种状态与转换
NEW状态：指线程刚刚创建，尚未启动。

Runnable状态：是线程正在正常运行， 可能会有某种耗时计算、IO等待、cpu时间片切换等，这个状态下可能发生的等待，而不是锁，sleep等。

Blocked状态：是在多个线程有同步操作的场景，比如在等待另一个线程的
synchronized块的执行释放：或者可重入的synchronized块里调用wait方法，也就是这里是线程在等待进入临界区。

WAITING这个状态：是指线程拥有了某个锁之后，调用了他的wait方法，等待其他线程notify或notifyall一遍该线程可以继续下一步操作，这里要区分BLOCKED和WATING的区别，一个是在临界点外面等待进入，一个是在临界点里面wait等待别人notify,线程调用了join方法，join了另外的线程的时候，也会进入WAITING状态，等待被他join的线程执行结束。

TIMED_WAITING这个状态：就是在限的（时间限制）的WAITING,一般出现在调用wait(long),join（long）等情况下，另外一个线程sleep后也会进入TIMED_WAITING状态。

TERMINATED 这个状态：表示该线程的run方法已经执行完毕了，基本上就等于死亡了。

二、线程的安全：在单线程中不会出现线程安全问题，而在多线程编程中，有可能会出现同时访问同一个资源的情况，这种资源可以是各种类型的的资源：一个变量、一个对象、一个文件、一个数据库表等，而当多个线程同时访问同一个资源的时候，就会存在一个问题：
　　由于每个线程执行的过程是不可控的，所以很可能导致最终的结果与实际上的愿望相违背或者直接导致程序出错。

三、多线程三个核心概念。

1、原子性：和数据库事务中的原子性一样，满足原子性特性的操作是不可中断的，要么全部执行成功要么全部执行失败。
	在多核CPU架构下，在同一时刻对同一共享变量执行 decl指令(递减指令，相当于i--，它分为三个过程:读->改->写，这个指令涉及到两次内存操作，那么在这种情况下i的结果是无法预测的。

2、有序性： 编译器和处理器为了优化程序性能而对指令序列进行重排序，也就是你编写的代码顺序和最终执行的指令顺序是不一致的，重排序可能会导致多线程程序出现内存可见性问题：CPU高速缓存以及指令重排序都会造成可见性问题。

3、可见性：多个线程访问同一个共享变量时，其中一个线程对这个共享变量值的修改，其他线程能够立刻获得修改以后的值：
有序性简单来说就是程序代码执行的顺序是否按照我们编写代码的顺序执行，一般来说，为了提高性能，编译器和处理器会对指令做重排序，重排序分3类

编译器优化重排序，在不改变单线程程序语义的前提下，改变代码的执行顺序

指令集并行的重排序，对于不存在数据依赖的指令，处理器可以改变语句对应指令的执行顺序来充分利用CPU资源

内存系统的重排序，也就是前面说的CPU的内存乱序访问问题。

四、解决线程不安全的方法
方法一：同步方法锁
	同步方法：在方法声明上加上synchronized

	public synchronized void method(){

    	可能会产生线程安全问题的代码

	}　　
	同步方法中的锁对象是 this（即调用者对象）

	静态同步方法: 在方法声明上加上static synchronized

	public static synchronized void method(){

	可能会产生线程安全问题的代码

	}
方法二：同步块锁Synchronized锁特点：
1.获取锁的线程必须执行完，才会释放锁
2.获取锁的线程出现异常，此时JVM让线程自动释放锁
3.属于大粒度锁。比如无法做到读写冲突，读读不冲突

方法三：Lock锁：
1、Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性
2、锁的释放方式不同（自动、必须手动释放）
3、获取锁的方式更灵活
4、可以得到线程是否获取锁