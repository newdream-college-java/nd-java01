2.3	结果：Base	解析：在创建子类的对象时，jvm会首先执行父类的构造方法，然后再执行子类的构造方法，
	      Child	      如果是多级继承，会先执行最顶级父类的构造方法，然后依次执行各级个子类的构造方法

2.4	结果：Child中的共有的method()方法和私有的method方法发生方法名冲突。
	结果：在主方法内中的addOne方法中的数据类型不也能设置成finel，一旦设置即会报错要求其删除。

2.5	结果：A		解析：B.不构成方法的重写操作，而且方法设计不匹配   C. 无法构成方法的重载，其次形参getName前无void修饰！
	      		      D.子类继承父类虽然调用了getName方法虽运行不会出错但是违背了三相同，一放大原则

	结果：A		解析：name属于父类的私有类型，子类无法直接调用，只能通过get和set间接调用

	结果：B		解析：base是关键字无法调用，this是调用本类的数据，extends是继承只能去继承，而不是调用

	结果：C		解析：从主方法调用子类的method输出方法输出的是子类的输出语句
	
	结果：C		解析：A.抽象可以没有抽象方法，但是使用抽象方法其类必须是抽象类	B.  父类是抽象类子类可重写父类抽象方法也可以不重				 写，看需要即可。
			       D.父类抽象方法格式是不需要花括号，只有在子类要使用父类的抽象方法是需要花括号的
