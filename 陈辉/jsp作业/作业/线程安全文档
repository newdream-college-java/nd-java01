线程安全问题是指什么？
当多个线程共享同一个资源和全局变量的时候，导致数据的一致性不一样，产生的安全性问题。
一：Synchroniezd（内部锁） 锁的性质；使用synchronized之后，并不是说synchronized锁定的方法或者代码块要一次性执行完，才能跳转到其他线程。而是当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。也即是说，即使给某个方法加锁了，如果其他线程访问不是这个方法时，线程依然可以跳转；会出现问题就是因为在Synchroniezd 锁中加了一个休眠的属性，执行到那里的时候就直接跳转下一个线程，但是资源不会跳出，出现了数据的不一致的安全性问题。

所以会了解决这个问题出现了一个新的锁，、、
二：lock锁（显示锁）  线程安全问题是因为多个线程并发访问共享数据。于是很容易我们就想到将多个线程对共享数据的访问转换为串行访问。同一时刻只能有一个线程来访问共享数据。锁就是利用这种思路来保障线程安全的一种同步机制 
锁可以理解为对共享数据保证的许可证。一个线程只有在持有许可证的情况下才能访问共享数据，在结束共享数据的访问之后必须释放许可证，以便其它线程也能够获取到许可证对共享数据进行访问。lock锁 比较适合大众使用，因为它可以手动控制 

锁的用处：
1：同步代码块包含两个部分：一是作为锁的对象引用，一个是由该锁保护的代码块。
2：同步方法：当使用Synchronized代码块来修饰方法的时候。
3：非静态方法的锁就是方法调用所在的对象
4：静态方法的锁就是Class对象
5：每个Java对象都可以用作同步代码块的锁。线程在进入同步代码块的之前先获取锁，
6：退出同步代码块自动释放锁。不管是正常途径的退出还是发生异常。在这个过程中，
7：线程获取锁和释放锁都是由Java虚拟机来负责实施，这也正是synchronized
被称为内部锁的原因。


线程池：


什么是线程池，简单来说就是一个容器，来储备那些线程，实现线程重用的，因为有的线程不需要建立多次，可以实现反复使用，节约内存和空间......
就是用if判断的话，唤醒后线程会从wait之后的代码开始运行，但是不会重新判断if条件，直接继续运行if代码块之后的代码，而如果使用while的话，也会从wait之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行while代码块之后的代码块，成立的话继续wait（这是为什么用while,而不是用if的真正原因）

